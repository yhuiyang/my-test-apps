// ------------------------------------------------------------------------
// Headers
// ------------------------------------------------------------------------
#include <wx/wx.h>
#include <wx/thread.h>
#include <wx/dataview.h>
#include <wx/renderer.h>
#include <wx/filepicker.h>
#include <wx/hyperlink.h>
#include <wx/tokenzr.h>
#include <wx/filedlg.h>
#include <wx/textdlg.h>
#ifdef __WXMSW__
#include <iphlpapi.h>
#endif
#include "WidgetId.h"
#include "DownloadPane.h"
#include "SearchThread.h"
#include "UpdateThread.h"
#include "UpdaterApp.h"
#include "AppOptions.h"
#include "MacAddrUpdatePane.h"

// ------------------------------------------------------------------------
// Resources
// ------------------------------------------------------------------------
#include "img/search_32.xpm"
#include "img/download_to_chip2_64.xpm"

// ------------------------------------------------------------------------
// Declaration
// ------------------------------------------------------------------------
#define IMAGE_FILE_WILDCARD wxT("Bootloader or Firmware Binary Files(*.brec)|*.brec|All Files(*.*)|*.*")

class MyCustomToggleRenderer : public wxDataViewCustomRenderer
{
public:
    MyCustomToggleRenderer()
        : wxDataViewCustomRenderer(wxT("bool"),
            wxDATAVIEW_CELL_ACTIVATABLE)
    { m_toggle = false; }

    virtual bool Render(wxRect cell, wxDC *dc, int WXUNUSED(state))
    {
        int flags = 0;
        if (m_toggle)
            flags |= wxCONTROL_CHECKED;
        if (GetMode() != wxDATAVIEW_CELL_ACTIVATABLE)
            flags |= wxCONTROL_DISABLED;

        // check boxes we draw must always have the same, standard size (if it's
        // bigger than the cell size the checkbox will be truncated because the
        // caller had set the clipping rectangle to prevent us from drawing outside
        // the cell)
        cell.SetSize(GetSize());

        wxRendererNative::Get().DrawCheckBox(
                GetOwner()->GetOwner(),
                *dc,
                cell,
                flags );

        return true;
    }

    virtual bool Activate(wxRect WXUNUSED(cell), wxDataViewModel *model,
        const wxDataViewItem &item, unsigned int col)
    {
        model->ChangeValue(!m_toggle, item, col);
        return false;
    }

    virtual bool LeftClick(wxPoint WXUNUSED(cursor), wxRect WXUNUSED(cell),
        wxDataViewModel *model, const wxDataViewItem &item,
        unsigned int col)
    {
        model->ChangeValue(!m_toggle, item, col);
        return false;
    }

    virtual wxSize GetSize() const
    {
        // the window parameter is not used by GetCheckBoxSize() so it's
        // safe to pass NULL
        return wxRendererNative::Get().GetCheckBoxSize(NULL);
    }

    virtual bool SetValue(const wxVariant &value)
    {
        m_toggle = value.GetBool();
        return true;
    }

    virtual bool GetValue(wxVariant &WXUNUSED(value)) const { return true; }

    virtual int GetAlignment() const { return wxALIGN_CENTER; };

private:
    bool m_toggle;
};

// Custom event generated by MyCustomFilePathRenderer when MyCustomFilePathRenderer::Activate()
wxDECLARE_EVENT(myEVENT_DEVICE_SPECIFIC_FILE_ACTIVATED, wxCommandEvent);
wxDEFINE_EVENT(myEVENT_DEVICE_SPECIFIC_FILE_ACTIVATED, wxCommandEvent);

class MyCustomFilePathRenderer : public wxDataViewCustomRenderer
{
public:
    MyCustomFilePathRenderer()
        : wxDataViewCustomRenderer(wxT("string"),
            wxDATAVIEW_CELL_ACTIVATABLE)
    {
        m_path = wxEmptyString;
        m_emptyText = _("Double click to browse...");
    }

    virtual bool Render(wxRect cell, wxDC *dc, int state)
    {
        if (m_path.empty())
        {
            dc->SetBrush(*wxLIGHT_GREY_BRUSH);
            dc->SetPen(*wxTRANSPARENT_PEN);

            cell.Deflate(1);
            dc->DrawRoundedRectangle(cell, 5);

            RenderText(m_emptyText,
                0,
                wxRect(dc->GetTextExtent(m_emptyText)).CenterIn(cell),
                dc,
                state);
        }
        else
        {
            RenderText(m_path, 0, cell, dc, state);
        }
        return true;
    }

    virtual bool Activate(wxRect WXUNUSED(cell), wxDataViewModel *WXUNUSED(model),
        const wxDataViewItem &item, unsigned int WXUNUSED(col))
    {
        const wxDataViewCtrl *view = GetView();
        if (view)
        {
            int winId = view->GetId();
            wxCommandEvent evt(myEVENT_DEVICE_SPECIFIC_FILE_ACTIVATED, winId);
            if (item.IsOk())
            {
                int row = (int)(item.GetID()) - 1; // represent the row
                evt.SetEventObject(this);
                evt.SetInt(row);
                view->GetEventHandler()->ProcessEvent(evt);
            }
        }
        return false;
    }

    virtual wxSize GetSize() const
    {
        const wxDataViewCtrl *view = GetView();
        wxSize s = view->wxWindowBase::GetTextExtent(m_path.empty() ? m_emptyText : m_path);
        return s;
    }

    virtual bool SetValue(const wxVariant &value)
    {
        m_path = value.GetString();
        return true;
    }

    virtual bool GetValue(wxVariant &WXUNUSED(value)) const { return true; }

private:
    wxString m_path;
    wxString m_emptyText;
};

class MyCustomUpdateResultRenderer : public wxDataViewCustomRenderer
{
public:
    MyCustomUpdateResultRenderer()
        : wxDataViewCustomRenderer(wxT("string"),
            wxDATAVIEW_CELL_INERT)
    {
        m_result = wxEmptyString;
        m_ok = wxT("OK");
        m_error = wxT("ERROR");
        m_empty = true;
    }

    virtual bool Render(wxRect cell, wxDC *dc, int state)
    {
        long longValue = 0;

        if (!m_empty && m_result.ToLong(&longValue))
        {
            if (longValue)
                dc->SetBrush(*wxRED_BRUSH);
            else
                dc->SetBrush(*wxGREEN_BRUSH);
            dc->SetPen(*wxTRANSPARENT_PEN);

            cell.Deflate(2);
            dc->DrawRoundedRectangle(cell, 5);
            RenderText(longValue ? m_error : m_ok,
                0,
                wxRect(dc->GetTextExtent(longValue ? m_error : m_ok)).CenterIn(cell),
                dc,
                state);
        }
        else
        {
            RenderText(wxEmptyString, 0, cell, dc, state);
        }
        return true;
    }

    virtual wxSize GetSize() const
    {
        return wxSize(50, 20);
    }

    virtual bool SetValue(const wxVariant &value)
    {
        m_result = value.GetString();
        m_empty = m_result.empty();
        return true;
    }

    virtual bool GetValue(wxVariant &WXUNUSED(value)) const { return true; }

private:
    wxString m_result, m_ok, m_error;
    bool m_empty;
};

class DeviceList : public wxDataViewListCtrl
{
public:
    DeviceList(wxWindow *parent, wxWindowID id = wxID_ANY);

    enum
    {
        COLUMN_DEVICE_UPDATE,
        COLUMN_DEVICE_NAME,
        COLUMN_DEVICE_IPADDRESS,
        COLUMN_DEVICE_MACADDRESS,
        COLUMN_DEVICE_UPDATE_PROGRESS,
        COLUMN_DEVICE_SPECIFIC_IMAGE_FILE_PATH,
        COLUMN_DEVICE_UPDATE_RESULT,

        COLUMN_DEVICE_LIST_MAX
    };

private:
    void OnSelectionChanged(wxDataViewEvent &event);
    void OnItemActivated(wxDataViewEvent &event);
    void OnItemValueChanged(wxDataViewEvent &event);
};

class MyLinkAction : public wxHyperlinkCtrl
{
public:
    MyLinkAction(wxWindow *parent, wxWindowID id, const wxString &text)
        : wxHyperlinkCtrl(parent, id, text, wxEmptyString, wxDefaultPosition,
            wxDefaultSize, wxBORDER_NONE | wxHL_ALIGN_CENTRE)
    {
        SetVisitedColour(GetNormalColour());
    }
};

// ------------------------------------------------------------------------
// Implementation
// ------------------------------------------------------------------------
DeviceList::DeviceList(wxWindow *parent, wxWindowID id)
    : wxDataViewListCtrl(parent, id, wxDefaultPosition, wxDefaultSize,
    wxDV_SINGLE | wxDV_HORIZ_RULES | wxDV_VERT_RULES)
{
    int column;

    for (column = 0; column < COLUMN_DEVICE_LIST_MAX; column++)
    {
        switch (column)
        {
        case COLUMN_DEVICE_UPDATE:
            AppendColumn(new wxDataViewColumn(_("Update?"), new MyCustomToggleRenderer, column, 60));
            break;
        case COLUMN_DEVICE_NAME:
            AppendColumn(new wxDataViewColumn(_("Name"), new wxDataViewTextRenderer, column, 120, wxALIGN_LEFT));
            break;
        case COLUMN_DEVICE_IPADDRESS:
            AppendColumn(new wxDataViewColumn(_("IP Address"), new wxDataViewTextRenderer, column, 120, wxALIGN_LEFT));
            break;
        case COLUMN_DEVICE_MACADDRESS:
            AppendColumn(new wxDataViewColumn(_("MAC Address"), new wxDataViewTextRenderer, column, 120, wxALIGN_LEFT));
            break;
        case COLUMN_DEVICE_UPDATE_PROGRESS:
            AppendColumn(new wxDataViewColumn(_("Progress"), new wxDataViewProgressRenderer, column, 200, wxALIGN_LEFT));
            break;
        case COLUMN_DEVICE_SPECIFIC_IMAGE_FILE_PATH:
            AppendColumn(new wxDataViewColumn(_("Device-specific Image File Path"), new MyCustomFilePathRenderer, column, 250, wxALIGN_LEFT));
            break;
        case COLUMN_DEVICE_UPDATE_RESULT:
            AppendColumn(new wxDataViewColumn(_("Result"), new MyCustomUpdateResultRenderer, column, 80, wxALIGN_LEFT));
            break;
        default:
            break;
        }
    }

    //Bind(wxEVT_COMMAND_DATAVIEW_SELECTION_CHANGED, &DeviceList::OnSelectionChanged, this);
    //Bind(wxEVT_COMMAND_DATAVIEW_ITEM_ACTIVATED, &DeviceList::OnItemActivated, this);
    //Bind(wxEVT_COMMAND_DATAVIEW_ITEM_VALUE_CHANGED, &DeviceList::OnItemValueChanged, this);
}

void DeviceList::OnSelectionChanged(wxDataViewEvent &WXUNUSED(event))
{
    wxLogMessage(wxT("Selection changed"));
}

void DeviceList::OnItemActivated(wxDataViewEvent &WXUNUSED(event))
{
    wxLogMessage(wxT("Item activated"));
}

void DeviceList::OnItemValueChanged(wxDataViewEvent &WXUNUSED(event))
{
    wxLogMessage(wxT("Item value changed"));
}

BEGIN_EVENT_TABLE(DownloadPane, wxPanel)
    EVT_BUTTON(myID_DOWNLOAD_SEARCH_BTN, DownloadPane::OnSearchButtonClicked)
    EVT_BUTTON(myID_DOWNLOAD_SELECTED_BTN, DownloadPane::OnDownloadButtonClicked)
    EVT_UPDATE_UI(myID_DOWNLOAD_SEARCH_BTN, DownloadPane::OnUpdateSearchButton)
    EVT_UPDATE_UI(myID_DOWNLOAD_SELECTED_BTN, DownloadPane::OnUpdateDownloadButton)
    EVT_UPDATE_UI(myID_DOWNLOAD_GLOBAL_FILE, DownloadPane::OnUpdateGlobalFilePath)
    EVT_THREAD(myID_SEARCH_THREAD, DownloadPane::OnSearchThread)
    EVT_THREAD(myID_UPDATE_THREAD, DownloadPane::OnUpdateThread)
    EVT_HYPERLINK(myID_TARGET_CHECK_ALL, DownloadPane::OnDeviceCheckAll)
    EVT_HYPERLINK(myID_TARGET_UNCHECK_ALL, DownloadPane::OnDeviceUncheckAll)
    EVT_HYPERLINK(myID_DOWNLOAD_TARGET_LIST_SELECT_NONE, DownloadPane::OnDeviceListSelectNone)
    EVT_COMMAND(myID_DOWNLOAD_TARGET_LIST, myEVENT_DEVICE_SPECIFIC_FILE_ACTIVATED, DownloadPane::OnDeviceSpecificFileActivated)
END_EVENT_TABLE()

DownloadPane::DownloadPane()
{
    Init();
}

DownloadPane::DownloadPane(wxWindow *parent, wxWindowID id,
                         const wxPoint &pos, const wxSize &size,
                         long style)
{
    Init();
    Create(parent, id, pos, size, style);
}

DownloadPane::~DownloadPane()
{
    SaveOptionValue();
}

void DownloadPane::Init()
{
}

bool DownloadPane::Create(wxWindow *parent, wxWindowID id,
                         const wxPoint &pos, const wxSize &size,
                         long style)
{
    wxPanel::Create(parent, id, pos, size, style);
    CreateControls();
    InitOptionValue();
    Center();
    return true;
}

void DownloadPane::CreateControls()
{
    _promptForModifyMAC = new wxInfoBar(this);
    _promptForModifyMAC->AddButton(myID_MODIFY_MAC_BTN, _("Start to modify..."));
    // Must use dynamic event handler here, use static event table is not working here.
    // Becuase the button clicked event is handled in the wxInfoBar itself and don't propagate to it parent...
    _promptForModifyMAC->Bind(wxEVT_COMMAND_BUTTON_CLICKED, &DownloadPane::OnModifyMACButtonClicked, this, myID_MODIFY_MAC_BTN);
    _promptForModifyMAC->AddButton(wxID_ANY, _("Ignore"));
    _promptForModifyMAC->SetFont(GetFont().Bold().Larger());
    _promptForNotification = new wxInfoBar(this);
    _promptForNotification->SetFont(GetFont().Bold().Larger());

    wxStaticBoxSizer *listBoxSizer = new wxStaticBoxSizer(wxVERTICAL, this, _("Device list"));

    /* target list box */
    wxButton *search = new wxButton(this, myID_DOWNLOAD_SEARCH_BTN, wxT("Search"), wxDefaultPosition, wxDefaultSize, wxBU_EXACTFIT);
    search->SetBitmap(wxBitmap(search_32_xpm));
    search->SetBitmapDisabled(wxBitmap(wxImage(search_32_xpm).ConvertToGreyscale()));
    wxBoxSizer *searchSizer = new wxBoxSizer(wxHORIZONTAL);
    searchSizer->Add(search, 0, wxALL | wxEXPAND, 5);
    listBoxSizer->Add(searchSizer, 0, wxALL, 5);

    wxBoxSizer *selectSizer = new wxBoxSizer(wxHORIZONTAL);
    selectSizer->Add(new MyLinkAction(this, myID_TARGET_CHECK_ALL, _("Check All")), 0, wxLEFT, 5);
    selectSizer->Add(new MyLinkAction(this, myID_TARGET_UNCHECK_ALL, _("Uncheck All")), 0, wxLEFT | wxRIGHT, 5);
    selectSizer->Add(new MyLinkAction(this, myID_DOWNLOAD_TARGET_LIST_SELECT_NONE, _("Select None")), 0, wxLEFT, 5);
    listBoxSizer->Add(selectSizer, 0, wxALL, 0);

    DeviceList *tl = new DeviceList(this, myID_DOWNLOAD_TARGET_LIST);
    listBoxSizer->Add(tl, 1, wxALL | wxEXPAND, 5);

    /* target operation box */
    wxButton *download = new wxButton(this, myID_DOWNLOAD_SELECTED_BTN, _("Update selected"), wxDefaultPosition, wxDefaultSize, wxBU_EXACTFIT);
    download->SetBitmap(wxBitmap(download_to_chip2_64_xpm));
    download->SetBitmapDisabled(wxBitmap(wxImage(download_to_chip2_64_xpm).ConvertToGreyscale()));

    wxRadioButton *rb1 = new wxRadioButton(this, myID_DOWNLOAD_SPECIFIC_RB, _("Use Device-specific Image File"), wxDefaultPosition, wxDefaultSize, wxRB_GROUP);
    wxRadioButton *rb2 = new wxRadioButton(this, myID_DOWNLOAD_GLOBAL_RB, _("Use Global Image File"));
    wxBoxSizer *radioSizer = new wxBoxSizer(wxVERTICAL);
    radioSizer->AddStretchSpacer(1);
    radioSizer->Add(rb1, 0, wxALL, 5);
    radioSizer->Add(rb2, 0, wxALL, 5);

    wxFilePickerCtrl *filePicker = new wxFilePickerCtrl(this, myID_DOWNLOAD_GLOBAL_FILE, wxEmptyString, wxFileSelectorPromptStr, IMAGE_FILE_WILDCARD);
    wxBoxSizer *fileSizer = new wxBoxSizer(wxVERTICAL);
    fileSizer->AddStretchSpacer(1);
    fileSizer->Add(new wxStaticText(this, wxID_STATIC, _("Global Image File Path:")), 0, wxALL, 5);
    fileSizer->Add(filePicker, 0, wxALL | wxEXPAND, 5);

    wxStaticBoxSizer *operationBoxSizer = new wxStaticBoxSizer(wxHORIZONTAL, this, _("Device operation"));
    operationBoxSizer->Add(download, 0, wxALL | wxEXPAND, 5);
    operationBoxSizer->Add(radioSizer, 0, wxALL | wxEXPAND, 5);
    operationBoxSizer->Add(fileSizer, 1, wxALL | wxEXPAND, 5);

    wxBoxSizer *bgSizer = new wxBoxSizer(wxVERTICAL);
    bgSizer->Add(_promptForModifyMAC, wxSizerFlags().Expand());
    bgSizer->Add(_promptForNotification, wxSizerFlags().Expand());
    bgSizer->Add(listBoxSizer, 1, wxALL | wxEXPAND, 5);
    bgSizer->Add(operationBoxSizer, 0, wxALL | wxEXPAND, 5);

    SetSizer(bgSizer);
}

void DownloadPane::InitOptionValue()
{
    AppOptions *pOpt = wxGetApp().m_pAppOptions;
    wxString value;
    long longValue;

    if (pOpt)
    {
        // use global file
        wxRadioButton *globalRB = wxDynamicCast(FindWindow(myID_DOWNLOAD_GLOBAL_RB), wxRadioButton);
        if (globalRB && pOpt->GetOption(wxT("UseGlobalFile"), value))
        {
            if (value.ToLong(&longValue))
                globalRB->SetValue(longValue == 1);
        }

        // global file path
        wxFilePickerCtrl *filePicker = wxDynamicCast(FindWindow(myID_DOWNLOAD_GLOBAL_FILE), wxFilePickerCtrl);
        if (filePicker && pOpt->GetOption(wxT("GlobalFilePath"), value))
        {
            filePicker->SetPath(value);
        }
    }
}

void DownloadPane::SaveOptionValue()
{
    AppOptions *pOpt = wxGetApp().m_pAppOptions;
    wxString value;

    if (pOpt)
    {
        // use global file
        wxRadioButton *globalRB = wxDynamicCast(FindWindow(myID_DOWNLOAD_GLOBAL_RB), wxRadioButton);
        if (globalRB)
        {
            if (globalRB->GetValue())
                value = wxT("1");
            else
                value = wxT("0");
            pOpt->SetOption(wxT("UseGlobalFile"), value);
        }

        // global file path
        wxFilePickerCtrl *filePicker = wxDynamicCast(FindWindow(myID_DOWNLOAD_GLOBAL_FILE), wxFilePickerCtrl);
        if (filePicker)
        {
            pOpt->SetOption(wxT("GlobalFilePath"), filePicker->GetPath());
        }
    }
}

bool DownloadPane::IsMACAddressInvalid(const wxString &mac_address)
{
    int compare_result = wxGetApp().m_pAppOptions->GetOption(wxT("InvalidMACAddress")).CmpNoCase(mac_address);

    return (compare_result == 0);
}

wxString DownloadPane::ExplainUpdateThreadErrorCode(const int error)
{
    wxString msg;

    switch (error)
    {
    case UTERROR_BREC_SYNTAX:    
    case UTERROR_BAD_IMAGE_SYNTAX: msg = _("Wrong image file syntax"); break;
    case UTERROR_RAM_CHECKSUM: msg = _("Calculated checksum mismatched"); break;
    case UTERROR_BREC_CHECKSUM: msg = _("Wrong image file checksum"); break;
    case UTERROR_LOAD_MODE: msg = _("Unrecognize operation mode"); break;
    case UTERROR_VER: msg = _("Wrong version"); break;
    case UTERROR_MALLOC: msg = _("Memory allocation failed"); break;
    case UTERROR_ERASH_FLASH: msg = _("Can't erase flash memory"); break;
    case UTERROR_READ_FLASH: msg = _("Can't read flash memory"); break;
    case UTERROR_WRITE_FLASH: msg = _("Can't write flash memory"); break;
    case UTERROR_FW_SIZE: msg = _("Wrong firmware image size"); break;
    case UTERROR_BTL_SIZE: msg = _("Wrong bootloader image size"); break;
    case UTERROR_SOCKET_INIT: msg = _("Can't init socket"); break;
    case UTERROR_SOCKET_CONNECT: msg = _("Can't connect to remote"); break;
    case UTERROR_CONNECT: msg = _("Remote doesn't understand my protocol"); break;
    case UTERROR_FILE_STREAM: msg = _("Fail to read iamge file"); break;
    case UTERROR_SOCKET_WRITE: msg = _("Socket write error"); break;
    case UTERROR_SOCKET_READ: msg = _("Socket read error"); break;
    case UTERROR_UNKNOWN: msg = _("Unknown error"); break;
    default: msg = wxT("???"); break;
    }

    return msg;
}

//
// event handlers
//
void DownloadPane::OnSearchButtonClicked(wxCommandEvent &event)
{
    AppOptions *pOpt = wxGetApp().m_pAppOptions;
    wxString codedString, value;
    long longValue = 1;

    /* search count */
    if (pOpt && pOpt->GetOption(wxT("SearchCount"), value) && value.ToLong(&longValue))
        codedString << longValue;
    else
        codedString << wxT("1");
    /* broadcast method */
    codedString << SEARCH_THREAD_CODEDSTRING_DELIMIT_WORD;
    if (pOpt && pOpt->GetOption(wxT("SearchMethod"), value) && value.ToLong(&longValue))
        codedString << longValue;
    else
        codedString << wxT("0");

    /* active interface name */
    codedString << SEARCH_THREAD_CODEDSTRING_DELIMIT_WORD;
    codedString << pOpt->GetOption(wxT("ActivedInterface"));

    SearchThread *thread = new SearchThread(this, codedString);
    if (thread
        && (thread->Create() == wxTHREAD_NO_ERROR)
        && (thread->Run() == wxTHREAD_NO_ERROR))
    {
        wxDataViewListCtrl *lc = wxDynamicCast(FindWindow(myID_DOWNLOAD_TARGET_LIST), wxDataViewListCtrl);
        wxDataViewListStore *model;
        wxButton *btn = wxDynamicCast(event.GetEventObject(), wxButton);

        if (lc)
        {
            model = static_cast<wxDataViewListStore *>(lc->GetModel());
            model->DeleteAllItems();
        }
        if (btn)
            btn->Enable(false);

        wxGetApp().m_SearchThreadRunning = true;
    }
}

void DownloadPane::OnDownloadButtonClicked(wxCommandEvent &event)
{
    wxDataViewListCtrl *lc = wxDynamicCast(FindWindow(myID_DOWNLOAD_TARGET_LIST), wxDataViewListCtrl);
    wxRadioButton *rb = wxDynamicCast(FindWindow(myID_DOWNLOAD_GLOBAL_RB), wxRadioButton);
    wxFilePickerCtrl *filePicker = wxDynamicCast(FindWindow(myID_DOWNLOAD_GLOBAL_FILE), wxFilePickerCtrl);

    if (lc && rb)
    {
        wxString globalFile = filePicker->GetPath();
        wxDataViewListStore *store = lc->GetStore();
        bool useGlobalImage = rb->GetValue();

        if (store && ((useGlobalImage && !globalFile.empty()) || !useGlobalImage))
        {
            unsigned int row, nRow = store->GetCount();
            wxGetApp().m_UpdateThreadCount = 0;
            for (row = 0; row < nRow; row++)
            {
                wxString threadCodedWord;
                wxVariant data;
                store->GetValueByRow(data, row, DeviceList::COLUMN_DEVICE_UPDATE);
                if (data.GetBool())
                {
                    store->GetValueByRow(data, row, DeviceList::COLUMN_DEVICE_NAME);
                    wxString name = data.GetString();
                    store->GetValueByRow(data, row, DeviceList::COLUMN_DEVICE_IPADDRESS);
                    wxString ip = data.GetString();
                    store->GetValueByRow(data, row, DeviceList::COLUMN_DEVICE_MACADDRESS);
                    wxString mac = data.GetString();
                    store->GetValueByRow(data, row, DeviceList::COLUMN_DEVICE_SPECIFIC_IMAGE_FILE_PATH);
                    wxString specificFile = data.GetString();
                    if (!useGlobalImage && specificFile.empty())
                    {
                        wxString noSpecificFileMsg;
                        noSpecificFileMsg << wxT("Skip to update device") << wxT(" ") << name << wxT(", because of lack of device-specific image file path.");
                        _promptForNotification->ShowMessage(noSpecificFileMsg, wxICON_INFORMATION);
                        data = false;
                        store->SetValueByRow(data, row, DeviceList::COLUMN_DEVICE_UPDATE);
                        continue;
                    }
                    threadCodedWord.clear();
                    threadCodedWord
                        << row << UPDATE_THREAD_CODEDSTRING_DELIMIT_WORD
                        << name << UPDATE_THREAD_CODEDSTRING_DELIMIT_WORD
                        << ip << UPDATE_THREAD_CODEDSTRING_DELIMIT_WORD
                        << mac << UPDATE_THREAD_CODEDSTRING_DELIMIT_WORD
                        << wxGetApp().m_pAppOptions->GetOption(wxT("ActivedInterface"));

                    UpdateThread *thread = new UpdateThread(this, threadCodedWord, useGlobalImage ? globalFile : specificFile);
                    if (thread
                        && (thread->Create() == wxTHREAD_NO_ERROR)
                        && (thread->Run() == wxTHREAD_NO_ERROR))
                    {
                        wxGetApp().m_UpdateThreadCount++;
                    }
                }

                /* remove old result if it exists */
                store->GetValueByRow(data, row, DeviceList::COLUMN_DEVICE_UPDATE_RESULT);
                if (!data.GetString().empty())
                {
                    data = wxEmptyString;
                    store->SetValueByRow(data, row, DeviceList::COLUMN_DEVICE_UPDATE_RESULT);
                    store->RowChanged(row);
                }
                /* remove old progress if it exists */
                store->GetValueByRow(data, row, DeviceList::COLUMN_DEVICE_UPDATE_PROGRESS);
                if (data.GetLong() != 0)
                {
                    data = (long)0;
                    store->SetValueByRow(data, row, DeviceList::COLUMN_DEVICE_UPDATE_PROGRESS);
                    store->RowChanged(row);
                }
            }
            lc->UnselectAll();
        }
        else if (!store)
            wxLogError(wxT("Can not find store in wxDataViewListCtrl instance to validate required information!"));
        else if (useGlobalImage && globalFile.empty())
        {
            wxString noGlobalFileMsg;
            noGlobalFileMsg << _("Update procedure is skipped because of lack of global image file path.");
            _promptForNotification->ShowMessage(noGlobalFileMsg, wxICON_INFORMATION);
        }
    }
    else if (!lc)
    {
        wxLogError(wxT("Can not find wxDataViewListCtrl instance to validate required information!"));
    }
    else if (!rb)
    {
        wxLogError(wxT("Can not find wxRadioButton instance to validate required information!"));
    }

    if (wxGetApp().m_UpdateThreadCount)
    {
        /* Besides disable button in update ui event handler, we also disable button here
           right away to avoid this click action re-enter again */
        wxButton *btn = wxDynamicCast(event.GetEventObject(), wxButton);
        if (btn)
            btn->Enable(false);
    }
}

void DownloadPane::OnModifyMACButtonClicked(wxCommandEvent &event)
{
    wxStringTokenizer tokenzr;
    long loop = 0, longTemp;

    /* do nothing if there is update thread activity */
    if (wxGetApp().m_UpdateThreadCount)
    {
        _promptForNotification->ShowMessage(_("There is another update procedure running! Please wait it completed and try later..."), wxICON_EXCLAMATION);
        /* don't skip at here, so the button on infobar will not leave */
        return;
    }

    /* check if vendor and product codes setup completed */
    wxString vendor, firstProduct, lastProduct, currentProduct;
    vendor = wxGetApp().m_pAppOptions->GetOption(wxT("VendorCode"));
    firstProduct = wxGetApp().m_pAppOptions->GetOption(wxT("FirstProductCode"));
    lastProduct = wxGetApp().m_pAppOptions->GetOption(wxT("LastProductCode"));
    currentProduct = wxGetApp().m_pAppOptions->GetOption(wxT("CurrentProductCode"));
    if (vendor.empty() || firstProduct.empty() || lastProduct.empty())
        _promptForNotification->ShowMessage(_("MAC address auto-generation is disabled before you configure them done in the preference window!"), wxICON_EXCLAMATION);
    else if (currentProduct.empty())
        wxGetApp().m_pAppOptions->SetOption(wxT("CurrentProductCode"), firstProduct);

    /* check if we are running out of product code */
    if (!vendor.empty() && !firstProduct.empty() && !lastProduct.empty() && !currentProduct.empty())
    {
        long lastValue = 0, currentValue = 0;
        wxStringTokenizer tokenzr;
        wxString token;

        tokenzr.SetString(lastProduct, wxT(":"));
        loop = 0;
        while (tokenzr.HasMoreTokens())
        {
            token = tokenzr.GetNextToken();
            switch (loop++)
            {
            case 0: token.ToLong(&longTemp, 16); lastValue += (longTemp << 16); break;
            case 1: token.ToLong(&longTemp, 16); lastValue += (longTemp << 8); break;
            case 2: token.ToLong(&longTemp, 16); lastValue += longTemp; break;
            }
        }

        tokenzr.SetString(currentProduct, wxT(":"));
        loop = 0;
        while (tokenzr.HasMoreTokens())
        {
            token = tokenzr.GetNextToken();
            switch (loop++)
            {
            case 0: token.ToLong(&longTemp, 16); currentValue += (longTemp << 16); break;
            case 1: token.ToLong(&longTemp, 16); currentValue += (longTemp << 8); break;
            case 2: token.ToLong(&longTemp, 16); currentValue += longTemp; break;
            }
        }

        if (currentValue >= lastValue)
        {
            _promptForNotification->ShowMessage(_("The MAC address pool had run out! Please re-configure."), wxICON_ERROR);
            return;
        }
    }

    /* invoke MacAddrUpdatePane */
    wxWindow *pane = new MacAddrUpdatePane(GetParent(), wxID_ANY, _preparedUpdateThreadCodedString);
    wxPoint panePos;
    panePos.x = (wxGetDisplaySize().GetWidth() - pane->GetSize().GetWidth()) / 2;
    panePos.y = (wxGetDisplaySize().GetHeight() - pane->GetSize().GetHeight()) / 2;
    wxGetApp().m_AuiManager.AddPane(pane,
        wxAuiPaneInfo().Caption(_("Update MAC Address")).Float().FloatingPosition(panePos));
    wxGetApp().m_AuiManager.Update();

    // just call skip here, so this event will be handled by the wxInfoBarBase, which will hide the infobar.
    event.Skip();
}

void DownloadPane::OnUpdateSearchButton(wxUpdateUIEvent &event)
{
    event.Enable((wxGetApp().m_UpdateThreadCount == 0) && (wxGetApp().m_SearchThreadRunning == false));
}

void DownloadPane::OnUpdateDownloadButton(wxUpdateUIEvent &event)
{
    wxRadioButton *rb = wxDynamicCast(FindWindow(myID_DOWNLOAD_GLOBAL_RB), wxRadioButton);
    wxFilePickerCtrl *picker = wxDynamicCast(FindWindow(myID_DOWNLOAD_GLOBAL_FILE), wxFilePickerCtrl);
    wxDataViewListCtrl *lc = wxDynamicCast(FindWindow(myID_DOWNLOAD_TARGET_LIST), wxDataViewListCtrl);
    wxDataViewListStore *store;
    bool at_least_one_is_checked = false, use_global_file = true, all_files_are_ok = true;
    unsigned int row, nRow;
    wxVariant data;

    if (lc && rb && picker)
    {
        /* if use global file, only need to check the global file path */
        use_global_file = rb->GetValue();
        if (use_global_file)
        {
            wxFileName globalFile(picker->GetPath());
            if (!globalFile.FileExists())
                all_files_are_ok = false;
        }

        /* if use device-specific file, need to check file path for every checked row */
        store = lc->GetStore();
        nRow = store->GetCount();
        for (row = 0; row < nRow; row++)
        {
            store->GetValueByRow(data, row, DeviceList::COLUMN_DEVICE_UPDATE);
            if (data.GetBool())
            {
                at_least_one_is_checked = true;
                if (use_global_file)
                    break;
                else
                {
                    store->GetValueByRow(data, row, DeviceList::COLUMN_DEVICE_SPECIFIC_IMAGE_FILE_PATH);
                    wxFileName specificFile(data.GetString());
                    if (!specificFile.FileExists())
                    {
                        all_files_are_ok = false;
                        break;
                    }
                }
            }
        }
    }

    if ((wxGetApp().m_UpdateThreadCount == 0)
        && at_least_one_is_checked
        && all_files_are_ok)
        event.Enable(true);
    else
        event.Enable(false);
}

void DownloadPane::OnUpdateGlobalFilePath(wxUpdateUIEvent &event)
{
    wxRadioButton *useGlobalFile = wxDynamicCast(FindWindow(myID_DOWNLOAD_GLOBAL_RB), wxRadioButton);
    if (useGlobalFile && useGlobalFile->GetValue())
        event.Enable(true);
    else
        event.Enable(false);
}

void DownloadPane::OnSearchThread(wxThreadEvent &event)
{
    SearchThreadMessage msg = event.GetPayload<SearchThreadMessage>();
    wxDataViewListStore *model;
    wxDataViewListCtrl *lc;
    wxVector<wxVariant> data;
    wxString name, ip, mac;
    unsigned int nRow, row;
    bool found = false;
    wxVariant variant;
    int column;

    switch (msg.type)
    {
    case SEARCH_THREAD_COMPLETED:
        wxLogMessage(wxT("Device search thread is completed!"));
        wxGetApp().m_SearchThreadRunning = false;
        break;
    case SEARCH_THREAD_TARGET_FOUND:
        lc = wxDynamicCast(FindWindow(myID_DOWNLOAD_TARGET_LIST), wxDataViewListCtrl);
        if (lc)
        {
            model = static_cast<wxDataViewListStore *>(lc->GetModel());
            /* iterator all data in list to avoid the same data */
            nRow = model->GetCount();
            for (row = 0; row < nRow; row++)
            {
                model->GetValueByRow(variant, row, DeviceList::COLUMN_DEVICE_NAME);
                name = variant.GetString();
                model->GetValueByRow(variant, row, DeviceList::COLUMN_DEVICE_IPADDRESS);
                ip = variant.GetString();
                model->GetValueByRow(variant, row, DeviceList::COLUMN_DEVICE_MACADDRESS);
                mac = variant.GetString();
                if ((name == msg.name) && (ip == msg.ip) && (mac == msg.mac))
                {
                    found = true;
                    break;
                }
            }

            if (!found)
            {
                for (column = 0; column < DeviceList::COLUMN_DEVICE_LIST_MAX; column++)
                {
                    switch (column)
                    {
                    case DeviceList::COLUMN_DEVICE_UPDATE:
                        data.push_back(false);
                        break;
                    case DeviceList::COLUMN_DEVICE_NAME:
                        data.push_back(msg.name);
                        break;
                    case DeviceList::COLUMN_DEVICE_IPADDRESS:
                        data.push_back(msg.ip);
                        break;
                    case DeviceList::COLUMN_DEVICE_MACADDRESS:
                        data.push_back(msg.mac);
                        break;
                    case DeviceList::COLUMN_DEVICE_UPDATE_PROGRESS:
                        data.push_back(0);
                        break;
                    case DeviceList::COLUMN_DEVICE_SPECIFIC_IMAGE_FILE_PATH:
                        data.push_back(wxEmptyString);
                        break;
                    case DeviceList::COLUMN_DEVICE_UPDATE_RESULT:
                        data.push_back(wxEmptyString);
                        break;
                    default:
                        // FIXME
                        data.push_back(0);
                        break;
                    }
                }
                lc->AppendItem(data);

                if (IsMACAddressInvalid(msg.mac)) // replace to invalid mac address
                {
                    wxString msg_to_modify_invalid_mac;

                    /* prepare update thread coded string for later button (on infobar) event handler */
                    _preparedUpdateThreadCodedString.clear();
                    _preparedUpdateThreadCodedString
                        << nRow << UPDATE_THREAD_CODEDSTRING_DELIMIT_WORD
                        << msg.name << UPDATE_THREAD_CODEDSTRING_DELIMIT_WORD
                        << msg.ip << UPDATE_THREAD_CODEDSTRING_DELIMIT_WORD
                        << msg.mac << UPDATE_THREAD_CODEDSTRING_DELIMIT_WORD
                        << wxGetApp().m_pAppOptions->GetOption(wxT("ActivedInterface"));

                    msg_to_modify_invalid_mac
                        << _("Device") << wxT(" ") << msg.name << wxT(" ") << _("with invalid MAC address")
                        << wxT(" (") << msg.mac << wxT(")! ") << _("Would you like to modify it?");
                    _promptForModifyMAC->ShowMessage(msg_to_modify_invalid_mac, wxICON_WARNING);
                }
            }
        }
        break;
    default:
        break;
    }
}

void DownloadPane::OnUpdateThread(wxThreadEvent &event)
{
    UpdateThreadMessage msg = event.GetPayload<UpdateThreadMessage>();
    wxDataViewListCtrl *lc;
    wxDataViewListStore *store;
    wxStringTokenizer tokenizer;
    int loop = 0, row = -1, error = UTERROR_UNKNOWN, progress = 0;
    long longValue;
    wxString name, ip;

    switch (msg.type)
    {
    case UPDATE_THREAD_DOWNLOAD_FIRMWARE_COMPLETED:
    case UPDATE_THREAD_DOWNLOAD_BOOTLOADER_COMPLETED:
    case UPDATE_THREAD_ERASE_MANAGEMENT_DATA_COMPLETED:
    case UPDATE_THREAD_DO_NOTHING_COMPLETED:

        tokenizer.SetString(msg.payload, UPDATE_THREAD_CODEDSTRING_DELIMIT_WORD);
        while (tokenizer.HasMoreTokens())
        {
            wxString token = tokenizer.GetNextToken();
            switch (loop++)
            {
            case 0: // row
                if (token.ToLong(&longValue))
                    row = (int)longValue;
                break;
            case 1: // name
                name = token;
                break;
            case 2: // ip
                ip = token;
                break;
            case 3: // mac
                break;
            case 4: // error
                if (token.ToLong(&longValue))
                {
                    error = (int)longValue;
                    wxLogVerbose(_("UpdateThread is completed with error code = %d"), error);
                }
                else
                {
                    wxLogError(_("UpdateThread is completed with unknown error code"));
                }
                break;
            default:
                break;
            }
        }

        if (error)
        {
            wxString msg_for_update_error;

            /* infobar don't show error message for modifying MAC or erasing management block */
            if ((msg.type != UPDATE_THREAD_MODIFY_MAC_ADDRESS_COMPLETED)
                && (msg.type != UPDATE_THREAD_ERASE_MANAGEMENT_DATA_COMPLETED))
            {
                msg_for_update_error << name << wxT(": ") << _("Can not download") << wxT(" ");
                if (msg.type == UPDATE_THREAD_DOWNLOAD_FIRMWARE_COMPLETED)
                    msg_for_update_error << _("firmware");
                else if (msg.type == UPDATE_THREAD_DOWNLOAD_BOOTLOADER_COMPLETED)
                    msg_for_update_error << _("Bootloader");
                else
                    msg_for_update_error << _("Image");
                msg_for_update_error << wxT("! ") << _("Reason") << wxT(" = ")
                    << ExplainUpdateThreadErrorCode(error) << wxT("!");
                _promptForNotification->ShowMessage(msg_for_update_error, wxICON_ERROR);
            }
        }

        if (((lc = wxDynamicCast(FindWindow(myID_DOWNLOAD_TARGET_LIST), wxDataViewListCtrl)) != NULL) && (row != -1))
        {
            if ((store = lc->GetStore()) != NULL)
            {
                wxString nameInList, ipInList;
                wxVariant data;

                //if (msg.type == UPDATE_THREAD_MODIFY_MAC_ADDRESS_COMPLETED)
                //{
                    /* update mac in list? */
                //}
                //else
                {
                    store->GetValueByRow(data, row, DeviceList::COLUMN_DEVICE_NAME);
                    nameInList = data.GetString();
                    store->GetValueByRow(data, row, DeviceList::COLUMN_DEVICE_IPADDRESS);
                    ipInList = data.GetString();
                    if ((name == nameInList) && (ip == ipInList))
                    {
                        data = wxString::Format(wxT("%d"), error);
                        store->SetValueByRow(data, row, DeviceList::COLUMN_DEVICE_UPDATE_RESULT);
                        store->RowChanged(row);
                    }
                }
            }
        }

        wxGetApp().m_UpdateThreadCount--;
        break;

    case UPDATE_THREAD_PROGRESS:

        tokenizer.SetString(msg.payload, UPDATE_THREAD_CODEDSTRING_DELIMIT_WORD);
        while (tokenizer.HasMoreTokens())
        {
            wxString token = tokenizer.GetNextToken();
            switch (loop++)
            {
            case 0: // row
                if (token.ToLong(&longValue))
                    row = (int)longValue;
                break;
            case 1: // name
                name = token;
                break;
            case 2: // ip
                ip = token;
                break;
            case 3: // mac
                break;
            case 4: // progress
                if (token.ToLong(&longValue))
                    progress = (int)longValue;
                break;
            default:
                break;
            }
        }

        if (((lc = wxDynamicCast(FindWindow(myID_DOWNLOAD_TARGET_LIST), wxDataViewListCtrl)) != NULL) && (row != -1))
        {
            if ((store = lc->GetStore()) != NULL)
            {
                wxString nameInList, ipInList;
                wxVariant data;
                store->GetValueByRow(data, row, DeviceList::COLUMN_DEVICE_NAME);
                nameInList = data.GetString();
                store->GetValueByRow(data, row, DeviceList::COLUMN_DEVICE_IPADDRESS);
                ipInList = data.GetString();
                if ((name == nameInList) && (ip == ipInList))
                {
                    data = (long)progress;
                    store->SetValueByRow(data, row, DeviceList::COLUMN_DEVICE_UPDATE_PROGRESS);
                    store->RowChanged(row);
                }
            }
        }
        break;
    default:
        wxLogWarning(wxT("Unsupported message type (%d) received!"), msg.type);
        break;
    }
}

void DownloadPane::OnDeviceCheckAll(wxHyperlinkEvent &WXUNUSED(event))
{
    wxDataViewListCtrl *lc = wxDynamicCast(FindWindow(myID_DOWNLOAD_TARGET_LIST), wxDataViewListCtrl);
    wxDataViewListStore *store;
    wxVariant data = true;

    if (lc)
    {
        if ((store = lc->GetStore()) != NULL)
        {
            unsigned int row, nRow = store->GetCount();
            for (row = 0; row < nRow; row++)
            {
                store->SetValueByRow(data, row, DeviceList::COLUMN_DEVICE_UPDATE);
            }

            /* this cause list refresh */
            if (nRow != 0)
                store->RowChanged(row - 1);
        }
    }
}

void DownloadPane::OnDeviceUncheckAll(wxHyperlinkEvent &WXUNUSED(event))
{
    wxDataViewListCtrl *lc = wxDynamicCast(FindWindow(myID_DOWNLOAD_TARGET_LIST), wxDataViewListCtrl);
    wxDataViewListStore *store;
    wxVariant data = false;

    if (lc)
    {
        if ((store = lc->GetStore()) != NULL)
        {
            unsigned int row, nRow = store->GetCount();
            for (row = 0; row < nRow; row++)
            {
                store->SetValueByRow(data, row, DeviceList::COLUMN_DEVICE_UPDATE);
            }

            /* this cause list refresh */
            if (nRow != 0)
                store->RowChanged(row - 1);
        }
    }
}

void DownloadPane::OnDeviceListSelectNone(wxHyperlinkEvent &WXUNUSED(event))
{
    wxDataViewListCtrl *lc = wxDynamicCast(FindWindow(myID_DOWNLOAD_TARGET_LIST), wxDataViewListCtrl);

    if (lc)
        lc->UnselectAll();
}

void DownloadPane::OnDeviceSpecificFileActivated(wxCommandEvent &event)
{
    wxRadioButton *useGlobalFile = wxDynamicCast(FindWindow(myID_DOWNLOAD_GLOBAL_RB), wxRadioButton);
    wxDataViewListCtrl *lc = wxDynamicCast(FindWindow(myID_DOWNLOAD_TARGET_LIST), wxDataViewListCtrl);
    wxDataViewListStore *store;
    int row = event.GetInt();
    wxString deviceName, msg;
    wxVariant data;
    
    if (useGlobalFile && !useGlobalFile->GetValue() && lc)
    {
        if ((store = lc->GetStore()) != NULL)
        {
            store->GetValueByRow(data, row, DeviceList::COLUMN_DEVICE_NAME);
            deviceName = data.GetString();
            msg << _("Select image file for device") << wxT(" ") << deviceName;

            wxFileDialog dlg(this, msg, wxEmptyString, wxEmptyString, IMAGE_FILE_WILDCARD,
                wxFD_OPEN | wxFD_FILE_MUST_EXIST);
            if (dlg.ShowModal() == wxID_OK)
            {
                data = dlg.GetPath();
                store->SetValueByRow(data, row, DeviceList::COLUMN_DEVICE_SPECIFIC_IMAGE_FILE_PATH);
            }
        }
    }
}
